import { Injectable, signal, computed, inject } from '@angular/core';
import { BehaviorSubject, Observable, Subject, interval, merge } from 'rxjs';
import { filter, map, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { WebrtcService } from './webrtc.service';
import { OfflineService } from './offline.service';
import { LocationService } from './location.service';
import { CryptoService } from './crypto.service';

export interface Message {
  id: string;
  type: 'text' | 'emergency' | 'location' | 'status' | 'system';
  priority: 'low' | 'normal' | 'high' | 'emergency';
  content: string;
  sender: {
    id: string;
    name: string;
    deviceType: string;
  };
  recipient?: {
    id: string;
    name: string;
  };
  location?: {
    latitude: number;
    longitude: number;
    accuracy: number;
    timestamp: number;
  };
  timestamp: number;
  status: 'draft' | 'sending' | 'sent' | 'delivered' | 'read' | 'failed';
  encrypted: boolean;
  signature?: string;
  retryCount: number;
  expiresAt?: number;
  emergencyData?: EmergencyData;
}

export interface EmergencyData {
  emergencyType: 'medical' | 'fire' | 'police' | 'natural_disaster' | 'accident' | 'other';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  contactInfo?: string;
  medicalInfo?: string;
  assistanceNeeded: string[];
  autoGenerated: boolean;
}

export interface MessageTemplate {
  id: string;
  name: string;
  type: 'emergency' | 'status' | 'custom';
  content: string;
  priority: 'normal' | 'high' | 'emergency';
  includeLocation: boolean;
  emergencyData?: Partial<EmergencyData>;
}

export interface MessageStats {
  totalSent: number;
  totalReceived: number;
  emergencyMessages: number;
  deliveryRate: number;
  averageLatency: number;
  failedMessages: number;
}

@Injectable({
  providedIn: 'root'
})
export class MessagingService {
  private webrtcService = inject(WebrtcService);
  private offlineService = inject(OfflineService);
  private locationService = inject(LocationService);
  private cryptoService = inject(CryptoService);

  // Signals for reactive state management
  private _messages = signal<Message[]>([]);
  private _messageQueue = signal<Message[]>([]);
  private _messageStats = signal<MessageStats>({
    totalSent: 0,
    totalReceived: 0,
    emergencyMessages: 0,
    deliveryRate: 0,
    averageLatency: 0,
    failedMessages: 0
  });

  // Computed signals
  messages = this._messages.asReadonly();
  messageQueue = this._messageQueue.asReadonly();
  messageStats = this._messageStats.asReadonly();
  
  emergencyMessages = computed(() => 
    this._messages().filter(m => m.type === 'emergency' || m.priority === 'emergency')
  );
  
  unreadMessages = computed(() => 
    this._messages().filter(m => m.status !== 'read' && m.sender.id !== this.getCurrentUserId())
  );
  
  pendingMessages = computed(() => 
    this._messages().filter(m => ['draft', 'sending'].includes(m.status))
  );

  // Subjects for events
  private messageReceived$ = new Subject<Message>();
  private messageStatusChanged$ = new Subject<{ messageId: string; status: Message['status'] }>();
  private emergencyAlert$ = new Subject<Message>();

  // Message templates
  private defaultTemplates: MessageTemplate[] = [
    {
      id: 'emergency-help',
      name: 'Yardım İhtiyacı',
      type: 'emergency',
      content: '🚨 ACİL DURUM: Yardıma ihtiyacım var! Lütfen yardım edin.',
      priority: 'emergency',
      includeLocation: true,
      emergencyData: {
        emergencyType: 'other',
        severity: 'high',
        description: 'Genel yardım talebi',
        assistanceNeeded: ['rescue', 'medical']
      }
    },
    {
      id: 'medical-emergency',
      name: 'Tıbbi Acil Durum',
      type: 'emergency',
      content: '🏥 TIBBİ ACİL DURUM: Tıbbi yardıma ihtiyacım var!',
      priority: 'emergency',
      includeLocation: true,
      emergencyData: {
        emergencyType: 'medical',
        severity: 'critical',
        description: 'Tıbbi acil durum',
        assistanceNeeded: ['medical', 'ambulance']
      }
    },
    {
      id: 'fire-emergency',
      name: 'Yangın',
      type: 'emergency',
      content: '🔥 YANGIN: Yangın var! İtfaiye gerekiyor!',
      priority: 'emergency',
      includeLocation: true,
      emergencyData: {
        emergencyType: 'fire',
        severity: 'critical',
        description: 'Yangın acil durumu',
        assistanceNeeded: ['fire_department', 'evacuation']
      }
    },
    {
      id: 'status-safe',
      name: 'Güvendeyim',
      type: 'status',
      content: '✅ Güvendeyim, durumum iyi.',
      priority: 'normal',
      includeLocation: true
    },
    {
      id: 'status-need-help',
      name: 'Yardım Gerekiyor',
      type: 'status',
      content: '⚠️ Yardıma ihtiyacım var ama acil değil.',
      priority: 'high',
      includeLocation: true
    }
  ];

  constructor() {
    this.initializeMessaging();
    this.setupMessageHandlers();
    this.startMessageProcessor();
  }

  private initializeMessaging(): void {
    // Load messages from offline storage
    this.loadMessagesFromStorage();
    
    // Setup WebRTC message handlers
    this.webrtcService.onDataReceived$.subscribe(data => {
      if (data.type === 'message') {
        this.handleIncomingMessage(data.payload);
      }
    });

    // Setup offline sync
    this.offlineService.onOnline$.subscribe(() => {
      this.processMessageQueue();
    });
  }

  private setupMessageHandlers(): void {
    // Handle message status updates
    this.webrtcService.onDataReceived$.pipe(
      filter(data => data.type === 'status')
    ).subscribe(data => {
      this.updateMessageStatus(data.payload.messageId, data.payload.status);
    });

    // Handle emergency messages
    this.messageReceived$.pipe(
      filter(message => message.type === 'emergency' || message.priority === 'emergency')
    ).subscribe(message => {
      this.handleEmergencyMessage(message);
    });
  }

  private startMessageProcessor(): void {
    // Process message queue every 5 seconds
    interval(5000).subscribe(() => {
      this.processMessageQueue();
      this.updateMessageStats();
    });

    // Retry failed messages every 30 seconds
    interval(30000).subscribe(() => {
      this.retryFailedMessages();
    });
  }

  // Public API Methods

  async sendMessage(
    content: string, 
    type: Message['type'] = 'text',
    priority: Message['priority'] = 'normal',
    recipientId?: string,
    emergencyData?: EmergencyData
  ): Promise<string> {
    const messageId = this.generateMessageId();
    
    const message: Message = {
      id: messageId,
      type,
      priority,
      content,
      sender: {
        id: this.getCurrentUserId(),
        name: this.getCurrentUserName(),
        deviceType: this.getDeviceType()
      },
      recipient: recipientId ? {
        id: recipientId,
        name: await this.getUserName(recipientId)
      } : undefined,
      timestamp: Date.now(),
      status: 'draft',
      encrypted: true,
      retryCount: 0,
      emergencyData
    };

    // Add location if available and needed
    if (type === 'emergency' || type === 'location' || emergencyData) {
      const location = await this.locationService.getCurrentLocation();
      if (location) {
        message.location = {
          latitude: location.latitude,
          longitude: location.longitude,
          accuracy: location.accuracy,
          timestamp: location.timestamp
        };
      }
    }

    // Encrypt message
    try {
      const encryptedContent = await this.cryptoService.encryptMessage(content);
      message.content = encryptedContent.data;
      message.signature = encryptedContent.signature;
    } catch (error) {
      console.warn('Encryption failed, sending unencrypted:', error);
      message.encrypted = false;
    }

    // Add to messages and queue
    this.addMessage(message);
    this.addToQueue(message);

    // Try to send immediately if online
    if (this.webrtcService.isConnected()) {
      await this.sendMessageNow(message);
    }

    return messageId;
  }

  async sendEmergencyMessage(
    emergencyType: EmergencyData['emergencyType'],
    description: string,
    severity: EmergencyData['severity'] = 'high',
    assistanceNeeded: string[] = ['rescue']
  ): Promise<string> {
    const emergencyData: EmergencyData = {
      emergencyType,
      severity,
      description,
      assistanceNeeded,
      autoGenerated: false
    };

    const content = this.generateEmergencyContent(emergencyData);
    
    return this.sendMessage(
      content,
      'emergency',
      'emergency',
      undefined,
      emergencyData
    );
  }

  async sendTemplateMessage(templateId: string, customData?: Partial<MessageTemplate>): Promise<string> {
    const template = this.defaultTemplates.find(t => t.id === templateId);
    if (!template) {
      throw new Error(`Template not found: ${templateId}`);
    }

    const mergedTemplate = { ...template, ...customData };
    
    const allowedTypes: Message['type'][] = ['text', 'emergency', 'location', 'status', 'system'];
    const safeType = allowedTypes.includes(mergedTemplate.type as Message['type']) ? mergedTemplate.type : 'text';
    return this.sendMessage(
      mergedTemplate.content,
      safeType as Message['type'],
      mergedTemplate.priority,
      undefined,
      mergedTemplate.emergencyData as EmergencyData
    );
  }

  async broadcastEmergency(
    emergencyType: EmergencyData['emergencyType'],
    description: string,
    severity: EmergencyData['severity'] = 'critical'
  ): Promise<string[]> {
    const connectedPeers = this.webrtcService.getConnectedPeers();
    const messageIds: string[] = [];

    for (const peer of connectedPeers) {
      const messageId = await this.sendEmergencyMessage(
        emergencyType,
        description,
        severity,
        ['rescue', 'medical', 'evacuation']
      );
      messageIds.push(messageId);
    }

    return messageIds;
  }

  markAsRead(messageId: string): void {
    const messages = this._messages();
    const messageIndex = messages.findIndex(m => m.id === messageId);
    
    if (messageIndex !== -1) {
      const updatedMessages = [...messages];
      updatedMessages[messageIndex] = {
        ...updatedMessages[messageIndex],
        status: 'read'
      };
      this._messages.set(updatedMessages);
      this.saveMessagesToStorage();
    }
  }

  deleteMessage(messageId: string): void {
    const messages = this._messages().filter(m => m.id !== messageId);
    this._messages.set(messages);
    this.saveMessagesToStorage();
  }

  getMessagesByType(type: Message['type']): Message[] {
    return this._messages().filter(m => m.type === type);
  }

  getMessagesByPriority(priority: Message['priority']): Message[] {
    return this._messages().filter(m => m.priority === priority);
  }

  getConversation(peerId: string): Message[] {
    return this._messages().filter(m => 
      m.sender.id === peerId || m.recipient?.id === peerId
    ).sort((a, b) => a.timestamp - b.timestamp);
  }

  getMessageTemplates(): MessageTemplate[] {
    return this.defaultTemplates;
  }

  // Event Observables
  get onMessageReceived$(): Observable<Message> {
    return this.messageReceived$.asObservable();
  }

  get onMessageStatusChanged$(): Observable<{ messageId: string; status: Message['status'] }> {
    return this.messageStatusChanged$.asObservable();
  }

  get onEmergencyAlert$(): Observable<Message> {
    return this.emergencyAlert$.asObservable();
  }

  // Private Methods

  private async handleIncomingMessage(data: any): Promise<void> {
    try {
      let message: Message = data;

      // Decrypt message if encrypted
      if (message.encrypted && message.content) {
        try {
          const decryptedContent = await this.cryptoService.decryptMessage(
            message.content,
            message.signature ?? ''
          );
          message.content = decryptedContent;
        } catch (error) {
          console.error('Failed to decrypt message:', error);
          return;
        }
      }

      // Verify message integrity
      if (!this.verifyMessage(message)) {
        console.warn('Message verification failed:', message.id);
        return;
      }

      // Add to messages
      this.addMessage(message);
      
      // Send delivery confirmation
      await this.sendDeliveryConfirmation(message.id, message.sender.id);
      
      // Emit event
      this.messageReceived$.next(message);

      // Handle emergency messages
      if (message.type === 'emergency' || message.priority === 'emergency') {
        this.handleEmergencyMessage(message);
      }

    } catch (error) {
      console.error('Error handling incoming message:', error);
    }
  }

  private handleEmergencyMessage(message: Message): void {
    // Trigger emergency alert
    this.emergencyAlert$.next(message);
    
    // Auto-forward emergency messages to extend reach
    if (message.emergencyData?.severity === 'critical') {
      this.forwardEmergencyMessage(message);
    }
    
    // Log emergency for statistics
    this.updateEmergencyStats(message);
  }

  private async forwardEmergencyMessage(message: Message): Promise<void> {
    const connectedPeers = this.webrtcService.getConnectedPeers();
    
    for (const peer of connectedPeers) {
      if (peer.id !== message.sender.id) {
        await this.webrtcService.sendData(peer.id, {
          type: 'message',
          payload: message,
          priority: message.priority
        });
      }
    }
  }

  private async sendMessageNow(message: Message): Promise<void> {
    try {
      message.status = 'sending';
      this.updateMessage(message);

      if (message.recipient) {
        // Send to specific recipient
        await this.webrtcService.sendData(message.recipient.id, {
          type: 'message',
          payload: message,
          priority: message.priority
        });
      } else {
        // Broadcast to all connected peers
        const connectedPeers = this.webrtcService.getConnectedPeers();
        for (const peer of connectedPeers) {
          await this.webrtcService.sendData(peer.id, {
            type: 'message',
            payload: message,
            priority: message.priority
          });
        }
      }

      message.status = 'sent';
      this.updateMessage(message);
      this.removeFromQueue(message.id);

    } catch (error) {
      console.error('Failed to send message:', error);
      message.status = 'failed';
      message.retryCount++;
      this.updateMessage(message);
    }
  }

  private async sendDeliveryConfirmation(messageId: string, senderId: string): Promise<void> {
    try {
      await this.webrtcService.sendData(senderId, {
        type: 'status',
        payload: {
          messageId,
          status: 'delivered'
        },
        priority: 'normal'
      });
    } catch (error) {
      console.error('Failed to send delivery confirmation:', error);
    }
  }

  private updateMessageStatus(messageId: string, status: Message['status']): void {
    const messages = this._messages();
    const messageIndex = messages.findIndex(m => m.id === messageId);
    
    if (messageIndex !== -1) {
      const updatedMessages = [...messages];
      updatedMessages[messageIndex] = {
        ...updatedMessages[messageIndex],
        status
      };
      this._messages.set(updatedMessages);
      this.saveMessagesToStorage();
      
      this.messageStatusChanged$.next({ messageId, status });
    }
  }

  private async processMessageQueue(): Promise<void> {
    const queue = this._messageQueue();
    
    for (const message of queue) {
      if (this.webrtcService.isConnected()) {
        await this.sendMessageNow(message);
      }
    }
  }

  private async retryFailedMessages(): Promise<void> {
    const failedMessages = this._messages().filter(m => 
      m.status === 'failed' && m.retryCount < 3
    );

    for (const message of failedMessages) {
      if (this.webrtcService.isConnected()) {
        await this.sendMessageNow(message);
      }
    }
  }

  private addMessage(message: Message): void {
    const messages = this._messages();
    const existingIndex = messages.findIndex(m => m.id === message.id);
    
    if (existingIndex !== -1) {
      // Update existing message
      const updatedMessages = [...messages];
      updatedMessages[existingIndex] = message;
      this._messages.set(updatedMessages);
    } else {
      // Add new message
      this._messages.set([...messages, message]);
    }
    
    this.saveMessagesToStorage();
  }

  private updateMessage(message: Message): void {
    const messages = this._messages();
    const messageIndex = messages.findIndex(m => m.id === message.id);
    
    if (messageIndex !== -1) {
      const updatedMessages = [...messages];
      updatedMessages[messageIndex] = message;
      this._messages.set(updatedMessages);
      this.saveMessagesToStorage();
    }
  }

  private addToQueue(message: Message): void {
    const queue = this._messageQueue();
    if (!queue.find(m => m.id === message.id)) {
      this._messageQueue.set([...queue, message]);
    }
  }

  private removeFromQueue(messageId: string): void {
    const queue = this._messageQueue().filter(m => m.id !== messageId);
    this._messageQueue.set(queue);
  }

  private verifyMessage(message: Message): boolean {
    // Basic message validation
    return !!(
      message.id &&
      message.content &&
      message.sender?.id &&
      message.timestamp &&
      message.type
    );
  }

  private generateEmergencyContent(emergencyData: EmergencyData): string {
    const typeEmojis = {
      medical: '🏥',
      fire: '🔥',
      police: '🚔',
      natural_disaster: '🌪️',
      accident: '🚨',
      other: '⚠️'
    };

    const severityText = {
      low: 'Düşük',
      medium: 'Orta',
      high: 'Yüksek',
      critical: 'KRİTİK'
    };

    return `${typeEmojis[emergencyData.emergencyType]} ACİL DURUM
Tür: ${emergencyData.emergencyType.toUpperCase()}
Önem: ${severityText[emergencyData.severity]}
Açıklama: ${emergencyData.description}
Yardım Türü: ${emergencyData.assistanceNeeded.join(', ')}`;
  }

  private updateMessageStats(): void {
    const messages = this._messages();
    const sent = messages.filter(m => m.sender.id === this.getCurrentUserId());
    const received = messages.filter(m => m.sender.id !== this.getCurrentUserId());
    const emergency = messages.filter(m => m.type === 'emergency');
    const delivered = messages.filter(m => ['delivered', 'read'].includes(m.status));
    const failed = messages.filter(m => m.status === 'failed');

    this._messageStats.set({
      totalSent: sent.length,
      totalReceived: received.length,
      emergencyMessages: emergency.length,
      deliveryRate: sent.length > 0 ? (delivered.length / sent.length) * 100 : 0,
      averageLatency: this.calculateAverageLatency(messages),
      failedMessages: failed.length
    });
  }

  private updateEmergencyStats(message: Message): void {
    const stats = this._messageStats();
    this._messageStats.set({
      ...stats,
      emergencyMessages: stats.emergencyMessages + 1
    });
  }

  private calculateAverageLatency(messages: Message[]): number {
    const deliveredMessages = messages.filter(m => 
      m.status === 'delivered' && m.sender.id === this.getCurrentUserId()
    );
    
    if (deliveredMessages.length === 0) return 0;
    
    // This is a simplified calculation - in real implementation,
    // you'd track actual delivery timestamps
    return 2500; // Average 2.5 seconds
  }

  private async loadMessagesFromStorage(): Promise<void> {
    try {
      const messages = await this.offlineService.getData<Message[]>('messages') || [];
      this._messages.set(messages);
    } catch (error) {
      console.error('Failed to load messages from storage:', error);
    }
  }

  private async saveMessagesToStorage(): Promise<void> {
    try {
      await this.offlineService.storeData('messages', this._messages());
    } catch (error) {
      console.error('Failed to save messages to storage:', error);
    }
  }

  private generateMessageId(): string {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private getCurrentUserId(): string {
    return this.webrtcService.getLocalPeerId();
  }

  private getCurrentUserName(): string {
    return 'Kullanıcı'; // This should come from user profile service
  }

  private getDeviceType(): string {
    return 'mobile'; // This should be detected from device info
  }

  private async getUserName(userId: string): Promise<string> {
    // This should fetch from peer info or user directory
    return `Kullanıcı_${userId.substr(0, 6)}`;
  }
}